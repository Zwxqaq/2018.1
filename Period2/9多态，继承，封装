###继承  inherit   extends
    #单继承，便于类的拓展，但是不能修改父类
    #实现了代码的重用       不然你等于多写了很多累赘的代码
    #Object类是所有类的老祖宗，父类又叫超类基类
    #此处与拥有关系区别   我们肯定是说人类拥有了计算机类的属性，不能说是继承
    #继承的执行顺序：
        #属性/方法的查找顺序：
           #在当前类查找是否有这个属性，方法
           #如果没有，上溯每个父类，查看每个父类是否含有属性或者方法，直到Object
        #类与子类的初始化顺序：
           #构造方法的第一句总是super（）来调用父类对应的构造方法，所以流程是向上追溯到Object，再依次向下
           执行类和子类的初始化和构造方法，直到当前类止
###封装 encapsulation  胶囊
    #高内聚：内部数据操作细节自己完成，不允许外部干涉
    #低耦合：仅暴露少量方法给外部使用
            同一个类      同一个包      子类（可在不同包）      所有类
    #public     *            *          *                     *
    #protected  *            *          *            
    #default    *            *
    #private    *
    #封装要点：
        #对类的属性的处理
        #一般用private来修饰属性（除非确定本属性被子类继承）
        #提供相应getters/setters方法来访问相关属性，这些方法通常是public，只用于本类方法的可用private
        普通的getXxxx（）  setXxxx（），如果是boolean的get方法是用is开头
###多态
    #多态就是多种形态
    #构成多态的三个条件：
        #继承
        #重写
        #父类的引用指向子类的对象 Animal a=new Cat（）；
    #编译时类型：（模糊，一般是父类）由声明时的类型决定        父类的引用
    #运行时类型：（运行时，具体是哪个子类就是哪个子类）由实际对应的对象类型决定
    #instanceof       object instanceof class 是类的对象 返回true
    #对象的转型
        #向上转型：父类引用指向子类对象（属于自动类型转换）
        #向下转型：转换成子类本身（属于强制类型转换）
              #转型不当时：classCastException
              #如何避免异常：使用instanceof
